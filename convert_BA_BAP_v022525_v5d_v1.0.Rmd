---
title: "BA/BAP Converter (v1.0) — R Markdown"
date: "2026-02-24 (America/Boise)"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
---


<!--
File: convert_BA_BAP_v022525_v5d_v1.0.Rmd
Status: v1.0 FROZEN (scoring + filters locked)
Date: 2026-02-26

CHANGE LOG (major):
- v5c: Series summary NA cleanup post-pivot (presentation only)
- v5b: Output directory guards + write stability
- v5: Introduced pa_clean for summary-safe aggregation
- v4: Type normalization for multi-game robustness
- v3: Pitcher header-row filtering
- v2: Base/out state + DP handling
- v1.1: Introduced BAP (pitcher mirror)
- v1: Core BA + MaxOpp implemented
-->


# Overview

This document is an **R Markdown** version of the BA/BAP converter aligned to **`SCORING.md` v1.0**.

**What it does**

- Reads Baseball-Reference-style play-by-play exports (`.xlsx` and `.xls`, including HTML-in-`.xls`).
- Computes **BA** per plate appearance and **BAP = −BA** (pitcher mirror).
- Writes play-level and summary CSV outputs to `processed_output/` under the input folder.

**What it does *not* do (v1.0)**

- No plots/PDFs/boxscores.
- No accounting for independent non-PA events (balks, wild pitches, pickoffs, SB/CS).

# How to run

1. Open this `.Rmd` in **RStudio**.
2. Edit the `USER PATHS (EDIT ME)` section.
3. Click **Knit** (or run chunk-by-chunk).
4. Review outputs in `processed_output/`.

# Converter (fully annotated)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
```

## 1) Libraries

```{r libraries}
# install.packages(c("dplyr","stringr","purrr","readr","tibble","readxl","rvest","xml2","tidyr","stringi"))
library(dplyr)
library(stringr)
library(purrr)
library(readr)
library(tibble)
library(readxl)
library(rvest)
library(xml2)
library(tidyr)
library(stringi)
```

## 2) USER PATHS (EDIT ME)

```{r user_paths}
# -----------------------
# USER PATHS (EDIT ME)
# -----------------------
# Point input_dir to the folder containing your BR-export spreadsheets.
# The script writes outputs into input_dir/processed_output/

input_dir  <- "D:/APBA 22 Os CGPT/Data/Series_1_Series_2_Os_2022"
output_dir <- file.path(input_dir, "processed_output")

# Create once at setup
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

combined_out <- file.path(output_dir, "all_games_combined.csv")
leader_out   <- file.path(output_dir, "leaderboard.csv")
series_out   <- file.path(output_dir, "series_summary.csv")
pitcher_out  <- file.path(output_dir, "pitcher_BAP_leaderboard.csv")

# If TRUE, writes one processed CSV per input game (audit-friendly)
write_per_game <- TRUE
```

## 3) File readers

```{r file_readers}
# -----------------------
# FILE READERS
# -----------------------
# BR “.xls” exports are sometimes HTML tables saved with .xls extension.
# This detects that and parses accordingly.

is_html_xls <- function(path) {
  x <- readLines(path, n = 1, warn = FALSE)
  length(x) > 0 && str_detect(tolower(x[1]), "^<html")
}

read_game_table <- function(path) {
  ext <- tolower(tools::file_ext(path))
  if (ext == "xls" && is_html_xls(path)) {
    pg <- read_html(path)
    tabs <- html_table(pg, fill = TRUE)
    if (length(tabs) < 1) stop("No table found in ", basename(path))
    return(as_tibble(tabs[[1]]))
  }
  as_tibble(read_excel(path))
}
```

## 4) Column finders

```{r column_finders}
# -----------------------
# COLUMN FINDERS
# -----------------------
# Tries exact matches first, then falls back to pattern matching.

find_col <- function(df, candidates) {
  nms <- names(df)
  hit <- intersect(nms, candidates)
  if (length(hit) > 0) return(hit[[1]])
  idx <- which(str_detect(tolower(nms), paste(candidates, collapse = "|")))
  if (length(idx) > 0) return(nms[[idx[[1]]]])
  NA_character_
}

find_play_col <- function(df) {
  col <- find_col(df, c("Play Description", "Play Detail", "Play", "Description", "Details"))
  if (!is.na(col)) return(col)
  stop("No play-description column found.")
}
```

## 5) Filename parser

```{r filename_parser}
# -----------------------
# FILENAME PARSER
# -----------------------
# Best-effort extraction of game date and game number from filenames like:
#   04_08_22_Game_1_BAL_TB.xlsx

parse_filename_meta <- function(path) {
  base <- tools::file_path_sans_ext(basename(path))
  base <- str_replace_all(str_squish(base), " ", "")

  date_token <- str_extract(base, "^\\d{2}_\\d{2}_\\d{2}")
  game_date <- if (!is.na(date_token)) as.Date(date_token, "%m_%d_%y") else NA

  game_num <- as.integer(str_match(base, "Game_?(\\d+)")[, 2])

  after <- str_replace(base, "^\\d{2}_\\d{2}_\\d{2}_Game_?\\d+_?", "")
  parts <- unlist(str_split(after, "_"))
  parts <- parts[parts != ""]

  team_a <- if (length(parts) >= 1) parts[1] else NA
  team_b <- if (length(parts) >= 2) parts[2] else NA
  matchup <- if (!is.na(team_a) && !is.na(team_b)) paste0(team_a, "_vs_", team_b) else NA

  tibble(game_date, game_num, team_a, team_b, matchup)
}
```

## 6) Base-state helpers (RoB → mask, MaxOpp)

```{r base_state_helpers}
# -----------------------
# BASE STATE HELPERS
# -----------------------
# We encode base occupancy into a bitmask:
#   1st = 1, 2nd = 2, 3rd = 4
# e.g., runners on 1st & 3rd => mask 1 + 4 = 5

rob_to_mask <- function(rob) {
  if (is.na(rob)) return(0L)
  digs <- str_extract_all(as.character(rob), "[123]")[[1]]
  mask <- 0L
  if ("1" %in% digs) mask <- bitwOr(mask, 1L)
  if ("2" %in% digs) mask <- bitwOr(mask, 2L)
  if ("3" %in% digs) mask <- bitwOr(mask, 4L)
  mask
}

popcount_mask <- function(mask) {
  (bitwAnd(mask, 1L) != 0) + (bitwAnd(mask, 2L) != 0) + (bitwAnd(mask, 4L) != 0)
}

# MaxOpp per SCORING.md v1.0:
# 1st contributes 3, 2nd contributes 2, 3rd contributes 1
maxopp_from_mask <- function(mask) {
  (ifelse(bitwAnd(mask, 1L) != 0, 3L, 0L)) +
    (ifelse(bitwAnd(mask, 2L) != 0, 2L, 0L)) +
    (ifelse(bitwAnd(mask, 4L) != 0, 1L, 0L))
}

count_char <- function(x, ch) ifelse(is.na(x), 0L, str_count(as.character(x), fixed(ch)))
```

## 7) BA scoring (SCORING.md v1.0)

```{r ba_scoring}
# -----------------------
# BA SCORING (SCORING.md v1.0)
# -----------------------
# BA per PA:
#   + sum of base-steps advanced by pre-existing runners
#   - base-steps of pre-existing runners erased
#   - DP penalties
#
# Notes:
# - No “run bonus”
# - Batter self-advancement excluded
# - Forced movement on BB/HBP counts (+1 per forced runner step)
# - Explicit "to 2B" / "to 3B" tokens count +1 each
# - "Scores" is credited as terminal advancement from pre-existing base:
#     3rd->home=+1, 2nd->home=+2, 1st->home=+3
#   assigned conservatively to pre-existing runners closest to home first,
#   capped to number of pre-existing runners on base.
# - Runner erasures (forceouts) penalized by erased runner base
# - DP penalty: -1 (and -1 extra for lined DP)

calc_ba_v1 <- function(mask_before, text, outs_on_play) {
  t  <- ifelse(is.na(text), "", as.character(text))
  tl <- tolower(t)
  ba <- 0L

  # (1) Forced advancement: BB/HBP only
  if (str_detect(tl, "walk|hit by pitch")) {
    if (bitwAnd(mask_before, 1L) != 0) ba <- ba + 1L
    if (bitwAnd(mask_before, 2L) != 0 && bitwAnd(mask_before, 1L) != 0) ba <- ba + 1L
    if (bitwAnd(mask_before, 4L) != 0 &&
        bitwAnd(mask_before, 2L) != 0 &&
        bitwAnd(mask_before, 1L) != 0) ba <- ba + 1L
  }

  # (2) Explicit advancements
  ba <- ba + str_count(t, regex("\\bto\\s+2B\\b", TRUE))
  ba <- ba + str_count(t, regex("\\bto\\s+3B\\b", TRUE))

  # (3) Explicit "Scores" (pre-existing runners only)
  n_scores_raw <- str_count(t, regex("\\bScores\\b", TRUE))
  n_pre <- popcount_mask(mask_before)
  n_scores <- min(n_scores_raw, n_pre)

  if (n_scores > 0) {
    slots <- c()
    if (bitwAnd(mask_before, 4L) != 0) slots <- c(slots, 1L) # 3rd->home
    if (bitwAnd(mask_before, 2L) != 0) slots <- c(slots, 2L) # 2nd->home
    if (bitwAnd(mask_before, 1L) != 0) slots <- c(slots, 3L) # 1st->home
    ba <- ba + sum(head(slots, n_scores))
  }

  # (4) Runner erasures
  if (str_detect(t, "Forceout at 2B"))   ba <- ba - 1L
  if (str_detect(t, "Forceout at 3B"))   ba <- ba - 2L
  if (str_detect(t, "Forceout at Home")) ba <- ba - 3L

  # (5) Double play penalties
  if (str_detect(tl, "double play")) {
    ba <- ba - 1L
    if (outs_on_play >= 2 && str_detect(tl, "lined.*double play|line.*double play")) {
      ba <- ba - 1L
    }
  }

  ba
}
```

## 8) Process one game

```{r process_game}
# -----------------------
# PROCESS ONE GAME
# -----------------------
# Reads the file, maps required columns, normalizes names/teams,
# and computes BA/BAP + MaxOpp.

process_game <- function(path) {
  raw <- read_game_table(path)
  raw <- raw %>%
  dplyr::mutate(dplyr::across(dplyr::everything(), as.character))
  meta <- parse_filename_meta(path)

  col_inn    <- find_col(raw, c("Inn"))
  col_out    <- find_col(raw, c("Out", "Outs"))
  col_rob    <- find_col(raw, c("RoB", "ROB"))
  col_ro     <- find_col(raw, c("R/O", "RO", "R_O", "R-O"))
  col_bat    <- find_col(raw, c("@Bat", "Bat", "Batting", "Team"))
  col_batter <- find_col(raw, c("Batter"))
  col_pitch  <- find_col(raw, c("Pitcher"))
  col_play   <- find_play_col(raw)

  df <- raw %>%
    mutate(
      source_file = basename(path),
      game_date   = meta$game_date,
      game_num    = meta$game_num,
      matchup     = meta$matchup,
      Inn         = if (!is.na(col_inn)) as.character(.data[[col_inn]]) else NA,
      BatTeam     = if (!is.na(col_bat)) as.character(.data[[col_bat]]) else NA,
      Batter      = as.character(.data[[col_batter]]),
      Pitcher     = if (!is.na(col_pitch)) as.character(.data[[col_pitch]]) else NA,
      RoB_raw     = .data[[col_rob]],
      RO_raw      = .data[[col_ro]],
      Out_before  = suppressWarnings(as.integer(.data[[col_out]])),
      PlayText    = as.character(.data[[col_play]])
    )

  # Normalize names (stable grouping)
  df$Batter  <- stri_trans_general(df$Batter,  "Latin-ASCII") |> trimws()
  df$Pitcher <- stri_trans_general(df$Pitcher, "Latin-ASCII") |> trimws()

  # Team normalization (locked)
  df$BatTeam <- dplyr::recode(df$BatTeam,
    "Os"="BAL","Balt"="BAL","Orioles"="BAL",
    "TB"="TB","Rays"="TB","TBR"="TB",
    "MILW"="MIL","Brewers"="MIL",
    .default=df$BatTeam
  )

  # Compute BA/BAP + opportunity
  df <- df %>%
    mutate(
      mask_before  = map_int(RoB_raw, rob_to_mask),
      maxopp       = map_int(mask_before, maxopp_from_mask),
      outs_on_play = map_int(RO_raw, ~count_char(.x, "O")),
      runs_on_play = map_int(RO_raw, ~count_char(.x, "R")), # informational only
      BA_adj       = pmap_int(list(mask_before, PlayText, outs_on_play), calc_ba_v1),
      BAP_adj      = -BA_adj
    )

  df
}
```

## 9) Run folder + write outputs

```{r run_folder}
# -----------------------
# RUN FOLDER
# -----------------------
# SAFETY: ensure output directory exists at write-time
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
stopifnot(dir.exists(output_dir))


files <- list.files(input_dir, pattern = "\\.(xls|xlsx)$", full.names = TRUE, recursive = TRUE)
if (length(files) == 0) stop("No .xls/.xlsx files found under: ", input_dir)

all_games <- map_dfr(files, process_game)

# Clean plate-appearance rows only (removes BR inning header rows & other non-PA text rows)
pa_clean <- all_games %>%
  dplyr::filter(
    !is.na(Inn),
    stringr::str_detect(Inn, "^[tb][0-9]+$"),
    !is.na(BatTeam), !is.na(Batter),
    !stringr::str_detect(BatTeam, "Top of|Bottom of|Batting|facing"),
    !stringr::str_detect(Batter, "Top of|Bottom of|Batting|facing")
  )


# Optional per-game processed outputs (audit-friendly)
# Optional per-game processed outputs (audit-friendly)
if (isTRUE(write_per_game)) {
  ts <- format(Sys.time(), "%Y%m%d_%H%M%S")

  split(all_games, all_games$source_file) %>%
    purrr::imap(~{
      out_name <- paste0(tools::file_path_sans_ext(.y), "_processed_", ts, ".csv")
      readr::write_csv(.x, file.path(output_dir, out_name))
    })
}

# 1) Play-level combined output
write_csv(all_games, combined_out)

# 2) Batter leaderboard
batter_leaderboard <- pa_clean %>%
  dplyr::filter(
    !is.na(Batter),
    !is.na(BatTeam),
    Batter != "",
    BatTeam != "",
    # remove any lingering BR structural text
    !stringr::str_detect(BatTeam, "Top of|Bottom of|Batting|facing"),
    !stringr::str_detect(Batter, "Top of|Bottom of|Batting|facing")
  ) %>%
  dplyr::group_by(BatTeam, Batter) %>%
  dplyr::summarise(
    PA = dplyr::n(),
    BA = sum(BA_adj, na.rm = TRUE),
    MaxOpp = sum(maxopp, na.rm = TRUE),
    BA_per_MaxOpp = dplyr::if_else(MaxOpp > 0, BA / MaxOpp, 0),
    .groups = "drop"
  ) %>%
  dplyr::arrange(dplyr::desc(BA_per_MaxOpp), dplyr::desc(BA))
write_csv(batter_leaderboard, leader_out)

# 3) Per-game team summary + top 3 BA contributors
fmt_top3 <- function(d) {
  top <- d %>%
    group_by(Batter) %>%
    summarise(BA = sum(BA_adj), .groups = "drop") %>%
    arrange(desc(BA)) %>%
    slice_head(n = 3)
  paste0(top$Batter, "(", ifelse(top$BA >= 0, "+", ""), top$BA, ")", collapse = "; ")
}

series_summary <- pa_clean %>%
  dplyr::group_by(source_file, BatTeam) %>%
  dplyr::summarise(
    team_PA     = dplyr::n(),
    team_BA     = sum(BA_adj, na.rm = TRUE),
    team_MaxOpp = sum(maxopp, na.rm = TRUE),
    top3        = fmt_top3(dplyr::pick(dplyr::everything())),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    top3 = dplyr::coalesce(top3, "")
  ) %>%
  tidyr::pivot_wider(
    names_from  = BatTeam,
    values_from = c(team_PA, team_BA, team_MaxOpp, top3)
  ) %>%
  dplyr::mutate(
    dplyr::across(where(is.numeric), ~ tidyr::replace_na(.x, 0)),
    dplyr::across(where(is.character), ~ tidyr::replace_na(.x, ""))
  )
write_csv(series_summary, series_out)

# 4) Pitcher BAP leaderboard
pitcher_bap <- all_games %>%
  dplyr::filter(
    !is.na(Pitcher),
    Pitcher != "",
    !stringr::str_detect(Pitcher, "Batting|facing|Top of|Bottom of")
  ) %>%
  dplyr::group_by(Pitcher) %>%
  dplyr::summarise(
    BFP = dplyr::n(),
    BAP = sum(BAP_adj, na.rm = TRUE),
    MaxOpp = sum(maxopp, na.rm = TRUE),
    BAP_per_BFP = BAP / BFP,
    BAP_per_MaxOpp = dplyr::if_else(MaxOpp > 0, BAP / MaxOpp, 0),
    .groups = "drop"
  ) %>%
  dplyr::arrange(dplyr::desc(BAP_per_MaxOpp), dplyr::desc(BAP))

readr::write_csv(pitcher_bap, pitcher_out)

message("DONE — outputs written to: ", output_dir)
message("  - Combined play-level:     ", combined_out)
message("  - Batter leaderboard:      ", leader_out)
message("  - Series summary:          ", series_out)
message("  - Pitcher BAP leaderboard: ", pitcher_out)
```

# Debug helpers

These optional chunks help you validate the scoring quickly after a run. They do **not** change any scoring logic.

## Debug 1 — Confirm files were written

```{r debug_1_outputs, echo=TRUE}
# List files created in processed_output (your output folder)
if (exists("output_dir") && dir.exists(output_dir)) {
  list.files(output_dir, full.names = TRUE)
} else {
  message("output_dir not found or does not exist yet. Run the converter chunks first.")
}
```

## Debug 2 — Load combined output and check basic shape

```{r debug_2_load_combined, echo=TRUE}
combined_path <- if (exists("combined_out")) combined_out else NA_character_

if (!is.na(combined_path) && file.exists(combined_path)) {
  df_all <- readr::read_csv(combined_path, show_col_types = FALSE)
  dplyr::glimpse(df_all)
  message("Rows: ", nrow(df_all), " | Cols: ", ncol(df_all))
} else {
  message("Combined output not found yet: ", combined_path)
}
```

## Debug 3 — Non‑zero BAL batter BA events (Game 1 validation)

```{r debug_3_bal_nonzero_ba, echo=TRUE}
if (exists("df_all")) {
  bal_nonzero <- df_all %>%
    dplyr::filter(BatTeam == "BAL", BA_adj != 0) %>%
    dplyr::select(source_file, Inn, Batter, Pitcher, RoB_raw, PlayText, BA_adj, maxopp) %>%
    dplyr::arrange(source_file, Inn)

  bal_nonzero
} else {
  message("df_all not loaded. Run Debug 2 first.")
}
```

## Debug 4 — Non‑zero BAP events for a specific pitcher (e.g., Means)

```{r debug_4_pitcher_nonzero_bap, echo=TRUE}
if (exists("df_all")) {
  pitcher_name <- "Means"  # EDIT ME (e.g., "Means", "Lopez")
  pit_nonzero <- df_all %>%
    dplyr::filter(!is.na(Pitcher),
                  stringr::str_detect(Pitcher, stringr::fixed(pitcher_name, ignore_case = TRUE)),
                  BAP_adj != 0) %>%
    dplyr::select(source_file, Inn, Pitcher, Batter, RoB_raw, PlayText, BA_adj, BAP_adj, maxopp) %>%
    dplyr::arrange(source_file, Inn)

  pit_nonzero
} else {
  message("df_all not loaded. Run Debug 2 first.")
}
```

## Debug 5 — Game‑level invariant check (ΣBA + ΣBAP = 0)

```{r debug_5_invariant, echo=TRUE}
if (exists("df_all")) {
  inv <- df_all %>%
    dplyr::group_by(source_file) %>%
    dplyr::summarise(
      sum_BA  = sum(BA_adj, na.rm = TRUE),
      sum_BAP = sum(BAP_adj, na.rm = TRUE),
      check   = sum_BA + sum_BAP,
      .groups = "drop"
    )
  inv
} else {
  message("df_all not loaded. Run Debug 2 first.")
}
```

## Debug 6 — Quick Top‑N helpers

```{r debug_6_topn, echo=TRUE}
if (exists("df_all")) {
  top_batters <- df_all %>%
    dplyr::group_by(BatTeam, Batter) %>%
    dplyr::summarise(BA = sum(BA_adj), MaxOpp = sum(maxopp), PA = dplyr::n(), .groups="drop") %>%
    dplyr::mutate(BA_per_MaxOpp = dplyr::if_else(MaxOpp > 0, BA/MaxOpp, 0)) %>%
    dplyr::arrange(dplyr::desc(BA)) %>%
    dplyr::slice_head(n = 10)

  top_pitchers <- df_all %>%
    dplyr::filter(!is.na(Pitcher)) %>%
    dplyr::group_by(Pitcher) %>%
    dplyr::summarise(BAP = sum(BAP_adj), MaxOpp = sum(maxopp), BFP = dplyr::n(), .groups="drop") %>%
    dplyr::mutate(BAP_per_MaxOpp = dplyr::if_else(MaxOpp > 0, BAP/MaxOpp, 0)) %>%
    dplyr::arrange(dplyr::desc(BAP_per_MaxOpp)) %>%
    dplyr::slice_head(n = 10)

  list(top_batters = top_batters, top_pitchers = top_pitchers)
} else {
  message("df_all not loaded. Run Debug 2 first.")
}
```
